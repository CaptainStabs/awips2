/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.viz.alertviz.internal;

import java.io.File;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import com.raytheon.uf.common.message.StatusMessage;
import com.raytheon.uf.common.status.UFStatus.Priority;
import com.raytheon.uf.viz.alertviz.AlertvizException;
import com.raytheon.uf.viz.alertviz.Container;
import com.raytheon.uf.viz.alertviz.LogUtil.Order;
import com.raytheon.uf.viz.alertviz.config.Category;
import com.raytheon.uf.viz.core.VizApp;
import com.raytheon.uf.viz.core.localization.LocalizationManager;

/**
 * Stores the log messages in an internal derby database
 * 
 * <pre>
 * SOFTWARE HISTORY
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Sep 11, 2008 1433       chammack    Initial creation
 * Feb 11, 2016 5314       dgilling    Add loadByRowOffset.
 * Jul 11, 2016 5746       dgilling    Better control multi-threaded access to 
 *                                     Connection.
 * </pre>
 * 
 * @author chammack
 * @version 1.0
 */

public class LogMessageDAO {

    private static final String SELECT_ALL_QUERY = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log";

    private static final String SELECT_ALL_QUERY_BY_PK = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE pk = ?";

    private static final String SELECT_ALL_QUERY_BY_ROW_OFFSET = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log ORDER BY pk OFFSET ? ROWS FETCH NEXT ROW ONLY";

    private static final String MESSAGE_COUNT_QUERY = "SELECT COUNT(pk) FROM log";

    private static final String SELECT_ALL_BY_DATE_AND_SOURCE_AFTER = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE event_time > ?";

    private static final String SELECT_ALL_BY_DATE_AND_SOURCE_BEFORE = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE event_time < ?";

    private static final String SELECT_LAST_INSERT_ID = "SELECT IDENTITY_VAL_LOCAL() FROM log";

    private static final String INSERT_PREPARED_STATEMENT = "INSERT INTO log(event_time, category, priority, message, details, source) values (?, ?, ?, ?, ?, ?)";

    private static final String DB_CREATE = "CREATE TABLE log(pk INT NOT NULL GENERATED BY DEFAULT AS IDENTITY, event_time TIMESTAMP, category VARCHAR(64), source VARCHAR(64), priority INT, message VARCHAR(32672), details VARCHAR(32672), acknowledgedBy VARCHAR(32), acknowledgedAt TIMESTAMP)";

    private static final String PURGE_SELECT_STATEMENT = "SELECT pk FROM log WHERE event_time < ?";

    private static final String ACKNOWLEDGE = "UPDATE log SET acknowledgedAt = ? , acknowledgedBy = ? WHERE pk = ?";

    private Connection connection;

    private PreparedStatement saveStatement;

    private PreparedStatement getLastStatement;

    private static final String driver = "org.apache.derby.jdbc.EmbeddedDriver";

    private static final String startDatabase;

    private static final String stopDatabase;

    private static final String databaseDir;

    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");

    static {
        databaseDir = LocalizationManager.getUserDir() + File.separator
                + "logs" + File.separator + VizApp.getHostName();
        startDatabase = "jdbc:derby:directory:" + databaseDir + ";create=true";
        stopDatabase = "jdbc:derby:directory:" + databaseDir + ";shutdown=true";
    }

    private static LogMessageDAO instance = new LogMessageDAO();

    public static LogMessageDAO getInstance() {
        return instance;
    }

    private LogMessageDAO() {
    }

    private synchronized Connection getConnection() throws AlertvizException {
        if (connection != null) {
            try {
                if (connection.isClosed()) {
                    closeConnection();
                }
            } catch (SQLException e) {
                Container
                        .logInternal(
                                Priority.ERROR,
                                "Failed to connect to the AlertViz internal logging DB",
                                e);
                closeConnection();
            }
        }
        if (connection == null) {
            try {
                createConnection();
            } catch (Exception e) {
                // unable to create a connection, move alertViz log dir and
                // recreate
                Container
                        .logInternal(
                                Priority.ERROR,
                                "Unable to create connection to database, moving database dir to bad, and recreating from scratch",
                                e);
                moveLogDirToBackup();
                createConnection();
            }
        }

        return connection;
    }

    private void createConnection() throws AlertvizException {
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Class.forName(driver).newInstance();
            connection = DriverManager.getConnection(startDatabase);
            DatabaseMetaData dmd = connection.getMetaData();
            ResultSet tables = dmd.getTables(null, null, null,
                    new String[] { "TABLE" });
            boolean needCreation = true;

            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                if (tableName.equalsIgnoreCase("log")) {
                    needCreation = false;
                    break;
                }
            }

            if (needCreation) {
                statement = connection.createStatement();
                statement.execute(DB_CREATE);
            }
            connection.commit();
        } catch (Exception e1) {
            errorOccurred = true;
            throw new AlertvizException("Error setting up logging system", e1);
        } finally {
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    private void closeConnection() {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                // ignore
            }
            connection = null;
        }

        try {
            DriverManager.getConnection(stopDatabase);
        } catch (SQLException e) {
            // ignore as stop database will always throw an exception
        }
    }

    private void closeStatement(Statement statement) {
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void closeResultSet(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void moveLogDirToBackup() {
        File oldDir = new File(databaseDir);
        File newDir = null;
        synchronized (sdf) {
            boolean notFound = true;
            int count = 0;
            String basePath = databaseDir + "_bad_" + sdf.format(new Date())
                    + "_";
            while (notFound) {
                newDir = new File(basePath + count++);
                if (!newDir.exists()) {
                    notFound = false;
                }
            }
        }
        oldDir.renameTo(newDir);
    }

    public synchronized void save(StatusMessage sm) throws AlertvizException {
        Container.logInternal(sm);

        boolean errorOccurred = false;
        ResultSet rs = null;
        try {
            Connection conn = getConnection();
            if (saveStatement == null) {
                saveStatement = conn
                        .prepareStatement(INSERT_PREPARED_STATEMENT);
            }

            saveStatement.setTimestamp(1, new Timestamp(sm.getEventTime()
                    .getTime()));
            saveStatement.setString(2, sm.getCategory());
            saveStatement.setInt(3, sm.getPriority().ordinal());
            saveStatement.setString(4, sm.getMessage());
            saveStatement.setString(5, sm.getDetails());
            saveStatement.setString(6, sm.getSourceKey());
            saveStatement.executeUpdate();

            if (getLastStatement == null) {
                getLastStatement = conn.prepareStatement(SELECT_LAST_INSERT_ID);
            }

            rs = getLastStatement.executeQuery();
            if (rs.next()) {
                int id = rs.getInt(1);
                sm.setPk(id);
            }
            conn.commit();
        } catch (Exception e) {
            errorOccurred = true;
            throw new AlertvizException("Save failed", e);
        } finally {
            if (errorOccurred) {
                closeStatement(saveStatement);
                saveStatement = null;
                closeStatement(getLastStatement);
                getLastStatement = null;
                closeConnection();
            }
        }
    }

    public synchronized void acknowledge(StatusMessage sm, String username)
            throws AlertvizException {
        PreparedStatement updateStatement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            updateStatement = conn.prepareStatement(ACKNOWLEDGE);

            long ackTime = System.currentTimeMillis();
            updateStatement.setTimestamp(1, new Timestamp(ackTime));
            updateStatement.setString(2, username);
            updateStatement.setInt(3, sm.getPk());
            updateStatement.executeUpdate();
            sm.setAcknowledgedBy(username);
            sm.setAcknowledgedAt(new Date(ackTime));
            conn.commit();
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Acknowledge Failed", e);
        } finally {
            closeStatement(updateStatement);
            if (errorOccurred) {
                closeConnection();
            }

        }
    }

    public synchronized StatusMessage loadByPk(int pk) throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(SELECT_ALL_QUERY_BY_PK);
            statement.setInt(1, pk);

            rs = statement.executeQuery();

            conn.commit();
            return reconstituteResults(rs)[0];
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + pk, e);
        } catch (RuntimeException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + pk, e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    /**
     * Retrieves the specified status message from the message store using the
     * specified index as a row offset.
     * 
     * @param index
     *            The index of the message to retrieve
     * @return The status message
     * @throws AlertvizException
     *             If an error occurred retrieving the message from the message
     *             store.
     */
    public synchronized StatusMessage loadByRowOffset(int index)
            throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(SELECT_ALL_QUERY_BY_ROW_OFFSET);
            statement.setInt(1, index);

            rs = statement.executeQuery();

            conn.commit();
            return reconstituteResults(rs)[0];
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + index, e);
        } catch (RuntimeException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + index, e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public synchronized StatusMessage[] load(int count)
            throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(count);
            rs = statement.executeQuery(SELECT_ALL_QUERY);
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public synchronized StatusMessage[] load(int count, Timestamp filter,
            Order order) throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            if (order == Order.BEFORE) {
                statement = conn
                        .prepareStatement(SELECT_ALL_BY_DATE_AND_SOURCE_BEFORE);
            } else if (order == Order.AFTER) {
                statement = conn
                        .prepareStatement(SELECT_ALL_BY_DATE_AND_SOURCE_AFTER);
            } else {
                throw new IllegalArgumentException("Unsupported order : "
                        + order);
            }

            statement.setMaxFieldSize(count);
            statement.setTimestamp(1, filter);
            rs = statement.executeQuery();
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public synchronized StatusMessage[] load(int count, Category[] filter)
            throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            StringBuffer sb = new StringBuffer();
            sb.append("SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log  ");

            boolean first = true;
            for (Category cat : filter) {
                if (first) {
                    sb.append("WHERE ");
                    first = false;
                } else {
                    sb.append(" OR ");
                }

                sb.append("category = '" + cat.getCategoryName() + "'");

            }
            sb.append(" ORDER BY event_time");
            rs = statement.executeQuery(sb.toString());
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public synchronized Collection<Integer> purge(Timestamp filter)
            throws AlertvizException {
        boolean errorOccurred = false;
        Connection conn = getConnection();

        try (PreparedStatement purgeSelect = conn.prepareStatement(
                PURGE_SELECT_STATEMENT, ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_UPDATABLE)) {
            purgeSelect.setTimestamp(1, filter);

            try (ResultSet rs = purgeSelect.executeQuery()) {
                Collection<Integer> deletedKeys = new HashSet<>(512, 1f);
                while (rs.next()) {
                    deletedKeys.add(Integer.valueOf(rs.getInt(1)));
                    rs.deleteRow();
                }

                conn.commit();
                return Collections.unmodifiableCollection(deletedKeys);
            }
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error purging ", e);
        } finally {
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    /**
     * Retrieves the number of status messages in the message store.
     * 
     * @return Total number of messages.
     */
    public synchronized int getMessageCount() throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(1);
            rs = statement.executeQuery(MESSAGE_COUNT_QUERY);
            if (rs.next()) {
                int count = rs.getInt(1);
                return count;
            }
            conn.commit();
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error getting time range ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }

        return 0;
    }

    private StatusMessage[] reconstituteResults(ResultSet rs)
            throws SQLException {
        List<StatusMessage> retVal = new ArrayList<StatusMessage>();
        while (rs.next()) {
            StatusMessage sm = new StatusMessage();
            sm.setEventTime(rs.getTimestamp(1));
            sm.setCategory(rs.getString(2));
            sm.setPriority(Priority.values()[rs.getInt(3)]);
            sm.setMessage(rs.getString(4));
            sm.setDetails(rs.getString(5));
            sm.setSourceKey(rs.getString(6));
            sm.setPk(rs.getInt(7));
            sm.setAcknowledgedBy(rs.getString(8));

            Timestamp ts = rs.getTimestamp(9);
            if (ts != null) {
                sm.setAcknowledgedAt(new Date(ts.getTime()));
            }

            retVal.add(sm);
        }

        return retVal.toArray(new StatusMessage[retVal.size()]);
    }
}
